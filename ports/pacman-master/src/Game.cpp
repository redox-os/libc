/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/


#include "Game.h"

#define PAC	1
#define GHOST1 2
#define GHOST2 3
#define GHOST3 4
#define GHOST4 5

extern Log logtxt;
extern App app;
extern Settings settings;

void Game::editorSave() {
    int i=-1, j=-1;

    if ( settings.baddiestartx == -1 ||
         settings.baddiestarty == -1 ||
         settings.pacstartx == -1 ||
         settings.pacstarty == -1 ) {
        std::cerr << "Specify pacman and ghost start locations before saving\n";
        return;
    }

    //save

    std::ofstream file;
    bool error=0;		//1 on error


    if (editorpath == "") editorpath = "./levels/new/";
    file.open( (editorpath + MAPFILE).c_str()/*, std::ios::out */);

    if (!file) error=true;

    if (!error) {
        file << "/ Pacman Revolutions mapfile generated by Pacman level editor"	<< std::endl;
        for (j=0;j<settings.fieldheight; j++) {
            for (i=0;i<settings.fieldwidth; i++) {
                file << map[j*settings.fieldwidth+i] << "  ";
            }
            file << std::endl;
        }
    }

    if (file.is_open() ) file.close();


    file.open( (editorpath + OBJFILE).c_str() );
    if (!file) error=1;

    if (!error) {
        file << "/ Pacman Revolutions objectmap generated by Pacman level editor"	<< std::endl;
        for (j=0;j<settings.fieldheight; j++) {
            for (i=0;i<settings.fieldwidth; i++) {
                file << objmap[j*settings.fieldwidth+i] << "  ";
            }
            file << std::endl;
        }
    }

    if (file.is_open() ) file.close();

    file.open ( ( editorpath + CFGFILE ).c_str());
    if (!file) error=true;

    if (!error) {
        file << "/ Pacman Revolutions config file generated by Pacman level editor =;"	<< std::endl;
        file << "FIELDWIDTH=" << settings.fieldwidth << ";" << std::endl;
        file << "FIELDHEIGHT=" << settings.fieldheight << ";" << std::endl;
        file << "TILESIZE=" << settings.tilesize << ";" << std::endl;
        file << "PACSPEED=" << settings.pacspeed << ";" << std::endl;
        file << "BADDIESPEED=" << settings.baddiespeed << ";" << std::endl;
        file << "BADDIEIQ=" << settings.baddieiq << ";" << std::endl;
        file << "VULN_DURATION=" << settings.vuln_duration << ";" << std::endl;
        file << "PACSTARTX=" << settings.pacstartx  << ";" << std::endl;
        file << "PACSTARTY=" << settings.pacstarty << ";" << std::endl;
        file << "BADDIESTARTX=" << settings.baddiestartx << ";" << std::endl;
        file << "BADDIESTARTY=" << settings.baddiestarty << ";" << std::endl;
    }
    if ( file.is_open() ) file.close();

    bool isincluded = false;
    for (i=0;i< settings.lvlpathcount;i++) {
        if ( editorpath == settings.lvlpath[i] ) isincluded = true;
    }
    if ( !isincluded && !error) {
        file.open("pacman.cfg", std::ios::out | std::ios::app);
        if (!file) error=true;
        else {
            file << "\nLEVEL_PATH=" << editorpath;
            if (file.is_open()) file.close();
            settings.lvlpath.push_back(editorpath);
            settings.lvlpathcount++;
        }
    }


    if (error) {
        std::cerr << "Save failed";
    }
}

void Game::logicEditor() {

    if ( inputwaiting) {
        if ( key == LEFT ) {

            if ( activetool == 0 ) activetool = 15;
            else activetool--;
        }
        else if ( key == RIGHT ) {

            if ( activetool == 15 ) activetool = 0;
            else activetool++;
        }
        else if ( key == CLICK ) {
            if (activetool < 10)
                map[settings.fieldwidth*(mouseY / settings.tilesize)+(mouseX / settings.tilesize)] = activetool;
            else if (activetool == 14) {
                settings.pacstartx = mouseX / settings.tilesize;
                settings.pacstarty = mouseY / settings.tilesize;
            }
            else if (activetool == 15 ) {
                settings.baddiestartx = mouseX / settings.tilesize;
                settings.baddiestarty = mouseY / settings.tilesize;
            }
            else
                objmap[settings.fieldwidth*((mouseY - 10) / settings.tilesize)+((mouseX-10) / settings.tilesize)] = activetool-10;
        }
    }

}

void Game::renderEditor() {
    int i;

    objects[0]->Draw();

    for (i=1;i<10;i++) {
        if ( i == activetool )
            ((BckgrObj*)objects[0])->Draw( 10 + 30*i, settings.fieldheight * settings.tilesize + 5 , i, 0, 255);
        else
            ((BckgrObj*)objects[0])->Draw( 10 + 30*i, settings.fieldheight * settings.tilesize + 5 , i, 0, 100);
    }
    for (i=1;i<4;i++) {
        if ( i == activetool - 10 )
            ((BckgrObj*)objects[0])->Draw( 310 + 30*i, settings.fieldheight * settings.tilesize + 5 , i, 1, 255);
        else
            ((BckgrObj*)objects[0])->Draw( 310 + 30*i, settings.fieldheight * settings.tilesize + 5 , i, 1, 100);
    }
    if ( activetool == 14 ) {
        objects[PAC]->setAlpha(255);
        objects[PAC]->Draw(430, settings.fieldheight * settings.tilesize + 5 );
    }
    else {
        objects[PAC]->setAlpha(100);
        objects[PAC]->Draw(430, settings.fieldheight * settings.tilesize + 5 );
    }
    if ( activetool == 15 ) {
        objects[GHOST1]->setAlpha(255);
        objects[GHOST1]->Draw(480, settings.fieldheight * settings.tilesize + 5 );
    }
    else {
        objects[GHOST1]->setAlpha(100);
        objects[GHOST1]->Draw(480, settings.fieldheight * settings.tilesize + 5 );
    }

    objects[PAC]->Draw(settings.pacstartx*settings.tilesize, settings.pacstarty * settings.tilesize );
    objects[GHOST1]->Draw(settings.baddiestartx * settings.tilesize, settings.baddiestarty * settings.tilesize);

}

void Game::initEditor() {
    int i;

    if ( map ) delete[] map;
    if ( objmap ) delete[] objmap;

    //create new empty maps
    if ( editorpath == "" ) {
        map = new int[ settings.fieldheight * settings.fieldwidth ];
        objmap = new int[ settings.fieldheight * settings.fieldwidth ];

        for (i=0;i<settings.fieldheight * settings.fieldwidth;i++) {
            map[i]=0;
            objmap[i]=0;
        }
        settings.baddiestartx = -1;
        settings.baddiestarty = -1;
        settings.pacstartx = -1;
        settings.pacstarty = -1;
        settings.gatex = -1;
        settings.gatey = -1;
    }
    //load existing map
    else {

        //load settings

        settings.LoadSettings( editorpath + CFGFILE );

        //if level has different field size than currently selected, setup new window with proper size
        if (settings.fieldwidth*settings.tilesize != app.getScreen()->w
            || settings.fieldheight*settings.tilesize+EXTRA_Y_SPACE != app.getScreen()->h) {
            app.InitWindow();
            logtxt.print("window resized...");
        }

        //load maps

        map = new int[ settings.fieldheight * settings.fieldwidth ];
        objmap = new int[ settings.fieldheight * settings.fieldwidth ];

        loadMap( editorpath + MAPFILE, map);
        loadMap( editorpath + OBJFILE, objmap);

        //if loading is successful, set editorpath

    }

}
void Game::changeSkin() {
    int i;
    for (i=0;i<NUMOFOBJECTS;i++) objects[i]->LoadTextures( APP_PATH "/" + settings.skinspath[settings.skinspathcurrent] );
}
void Game::emptyMsgPump() {

    SDL_Event ev;

    while ( SDL_PollEvent(&ev) == 1 ) {
        switch(ev.type) {
        case SDL_KEYDOWN:
            switch (ev.key.keysym.sym ) {
            case SDLK_ESCAPE:
            case SDLK_q:
                app.setQuit(true);
                break;
            case SDLK_UP:
                processInput(UP);
                ((Pacman*)objects[1])->setNextDir( UP );
                break;
            case SDLK_DOWN:
                processInput(DOWN);
                ((Pacman*)objects[1])->setNextDir( DOWN );
                break;
            case SDLK_LEFT:
                processInput(LEFT);
                ((Pacman*)objects[1])->setNextDir( LEFT );
                break;
            case SDLK_RIGHT:
                processInput(RIGHT);
                ((Pacman*)objects[1])->setNextDir( RIGHT );
                break;
            case SDLK_SPACE:
                boost();
                break;
            case SDLK_p:
                if ( getState() == STATE_GAME )
                    pause();
                break;
            case SDLK_n:
                if ( getState() != STATE_ENTER_HSCORE )
                    gameInit();
                break;
            case SDLK_l:
                settings.lvlpathcurrent++;
                if ( settings.lvlpathcurrent >= settings.lvlpathcount)
                    settings.lvlpathcurrent=0;
                gameInit();
                break;
            case SDLK_s:
                settings.skinspathcurrent++;
                if ( settings.skinspathcurrent >= settings.skinspathcount)
                    settings.skinspathcurrent=0;
                changeSkin();
                break;
            case SDLK_e:
                initEditor();
                setState( STATE_EDITOR );
                break;
            case SDLK_w:
                //                        std::cerr << "w: save map not yet implemented";
                editorSave();
                break;
            case SDLK_f:
                toggleFps();
                break;
            case SDLK_h:
                setState( STATE_VIEW_HSCORE );
                break;
            case SDLK_RETURN:
                processInput(ENTER);
                break;
            default:
                break;
            }
            break;
        case SDL_MOUSEBUTTONDOWN:
            if ( getState() == STATE_EDITOR )
                processInput( CLICK, ev.button.x , ev.button.y);
            break;
        case SDL_MOUSEMOTION:
            if ( getState() == STATE_EDITOR && ev.motion.state&SDL_BUTTON(1) )
                processInput( CLICK, ev.motion.x, ev.motion.y);
            break;
        default:
            break;
        }
    }
}
void Game::toggleSound() {

    if ( app.getSnd()->on) {
        app.getSnd()->toggleSounds();
    }
    else {
        app.getSnd()->toggleSounds();

        if (gamestarted && !ispaused ) app.getSnd()->play(10, 1);
        if (gamestarted && vulnflag && !ispaused ) app.getSnd()->play(7, 1);
    }
}
void Game::clearHscore() {
    hscore.clear();
}

void Game::renderViewHscore() {
    shared_ptr<SDL_Surface>
            buf = app.getScreen(),
            txt;
    SDL_Color col;
    std::ostringstream ostr, scstr;
    SDL_Rect rect;
    int i, sc;
    std::string nm;

    col.r = col.g = col.b = 255;

    rect.x = settings.fieldwidth*settings.tilesize / 2 - 200;
    rect.w = 400;
    rect.y = settings.fieldheight*settings.tilesize / 2 - 200;
    rect.h = 50;

    try {
        // DRAW FIELD + SPRITES

        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->Draw();

        // DRAW SCORE + INFO

        for (i=1; i<lives; i++) {
            objects[PAC]->Draw( 350+i*50, settings.fieldheight*settings.tilesize);
        }
        if ( specialeaten ) objects[0]->Draw( settings.fieldwidth*settings.tilesize - 40 -10, settings.fieldheight*settings.tilesize +10 );

        ostr << "level: " << level << " score: " << score;

        txt.reset(TTF_RenderText_Solid(font,ostr.str().c_str(),col), SDL_FreeSurface);
        if (!txt) throw Error("DrawText failed");

        SDL_BlitSurface(txt.get(),NULL,buf.get(),&scorebox);

        // DRAW HIGHSCORES


        txt.reset(TTF_RenderText_Solid(font,"HIGHSCORES:",col), SDL_FreeSurface);
        if (!txt) throw Error("DrawText failed");

        SDL_BlitSurface(txt.get(),NULL,buf.get(),&rect);

        for (i=0;i<MAXENTRIES;i++) {

            nm= "";
            nm=hscore.getName(i);
            sc=hscore.getScore(i);

            rect.x = settings.fieldwidth * settings.tilesize / 4;
            rect.w = 200;
            rect.y = 200 + i*50;
            rect.h = 50;

            if ( nm != "" ) {
                txt.reset(TTF_RenderText_Solid(font,nm.c_str(),col), SDL_FreeSurface);
                if (!txt) throw Error("DrawText failed");

                SDL_BlitSurface(txt.get(),NULL,buf.get(),&rect);
            }

            rect.x = settings.fieldwidth * settings.tilesize / 4 + 200;


            scstr.str("");
            if ( sc ) {
                scstr << sc;
                txt.reset(TTF_RenderText_Solid(font,scstr.str().c_str(),col), SDL_FreeSurface);
                if (!txt) throw Error("DrawText failed");

                SDL_BlitSurface(txt.get(),NULL,buf.get(),&rect);
            }
        }

    }
    catch ( Error& err ) {
        std::cerr << err.getDesc();
        app.setQuit(true);
        logtxt.print( err.getDesc() );
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in RenderViewHscore";
        app.setQuit(true);
        logtxt.print( "Unexpected error" );
    }
}

void Game::setState(int st) {
    int i;

    if ( st == STATE_GAME ) {
        app.getSnd()->stop();
        app.getSnd()->play(10,1);

        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) objects[i]->setAlpha(255);
        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->setPaused( false);

    }
    else if ( st == STATE_ENTER_HSCORE ) {

        app.getSnd()->stop();

        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->setPaused( true);
        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) objects[i]->setAlpha(150);

    }
    else if ( st == STATE_VIEW_HSCORE ) {


        app.getSnd()->stop();
        app.getSnd()->play( 11, 0);

        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) objects[i]->setAlpha(150);
        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->setPaused( true);
    }
    else if ( st == STATE_STOPPED && state != STATE_STOPPED) {
        app.getSnd()->stop();
        app.getSnd()->play(0, 1);
        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->setPaused( true);
        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) objects[i]->setAlpha(255);
    }
    else if ( st == STATE_EDITOR ) {

        app.getSnd()->stop();

        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]) objects[i]->setAlpha(255);

        activetool = 1;
    }

    state = st;

}

void Game::logicEnterHscore() {
    int j;

    if ( inputwaiting ) {

        switch ( key ) {
        case RIGHT :
            if (hscoreselection==2) hscoreselection=0;
            else hscoreselection++;
            for (j=0;j<3;j++) namecol[j]= 150;
            namecol[ hscoreselection ] = 255;
            break;
        case LEFT :
            if (hscoreselection==0) hscoreselection=2;
            else hscoreselection--;
            for (j=0;j<3;j++) namecol[j]= 150;
            namecol[ hscoreselection ] = 255;
            break;
        case DOWN :
            if (name[hscoreselection]=='A') name[hscoreselection]='_';
            else if (name[hscoreselection]=='_') name[hscoreselection]='Z';
            else name[hscoreselection]--;
            break;
        case UP :
            if (name[hscoreselection]=='Z') name[hscoreselection]='_';
            else if (name[hscoreselection]=='_') name[hscoreselection]='A';
            else name[hscoreselection]++;
            break;
        case ENTER :
            hscore.add(name, score);
            hscore.save();

            setState( STATE_VIEW_HSCORE) ;
        default :
             break;
        }
    }
}
void Game::logicGame() {
    int
            i, j,
            delta,
            pacX,
            pacY,
            pacXpix,
            pacYpix,
            ghostXpix[4],
            ghostYpix[4],
            oldscore(score);

    delta = (int)(time -oldtime);

    if ( gamestarted && !ispaused ) {

        //////////////////////////////////
        //	GET POSITIONS
        //////////////////////////////////

        pacXpix = ((Pacman*)objects[PAC])->getXpix();
        pacYpix = ((Pacman*)objects[PAC])->getYpix();
        pacX= (pacXpix + settings.tilesize / 2) / settings.tilesize;
        pacY= (pacYpix + settings.tilesize / 2) / settings.tilesize;
        for (i=0;i<4;i++) {
            ghostXpix[i]= ((Ghost*)objects[i+2])->getXpix();
            ghostYpix[i]= ((Ghost*)objects[i+2])->getYpix();
        }

        //////////////////////////////////
        // MOVE LOGIC
        //////////////////////////////////

        if ( delta < 100 )  {
            //set ghost targets - 2 on pacman, 2 on next intersection

            {
                int tmpx(  pacXpix / settings.tilesize),
                tmpy(  pacYpix / settings.tilesize);

                ((Ghost*)objects[GHOST1])->setTarget( tmpx, tmpy);
                ((Ghost*)objects[GHOST2])->setTarget( tmpx, tmpy);

                ((Pacman*)objects[PAC])->nextIntersection ( tmpx, tmpy);

                ((Ghost*)objects[GHOST3])->setTarget( tmpx, tmpy);
                ((Ghost*)objects[GHOST4])->setTarget( tmpx, tmpy);
            }

            //move objects

            for (i=0;i<NUMOFOBJECTS;i++)
                objects[i]->Update( delta );
        }
        ///////////////////////////////////////////
        //	TIME LOGIC
        ///////////////////////////////////////////

        //if ghost timer is up, set ghosts to normal mode

        if ( vulnflag && time > ghosttick ) {
            for (i=0;i<4;i++) {
                if ( ((Ghost*)objects[i+2])->getState() != 3) ((Ghost*)objects[i+2])->setState(0);
            }
            vulnflag= false;
            deadghostcount= 0;

            app.getSnd()->stop(7);
        }

        // if less than 2 secs left in vuln mode, set warning mode

        else if ( vulnflag && time > ghosttick -2000) for (i=0;i<4;i++) {
            ((Ghost*)objects[i+2])->setState(2);
            //			app.getSnd()->modify( 7, 44100 + (2000 - (ghosttick-time))*10 );
        }

        // fruit stuff

        if ( specialspawned && !specialeaten && (fruittick - time < 2000) ) {
            ((BckgrObj*)objects[0])->setFruitAlpha( 55 + (fruittick - time) / 10 );
        }
        if ( time > fruittick && specialspawned && !specialeaten) {
            specialspawned = false;
            ((BckgrObj*)objects[0])->setSpecialSpawned(false);
        }

        // pac booster

        if ( isboosted && time > boosttick ) {
            isboosted = false;
            ((Pacman*)objects[PAC])->setSpeedMult( 1 );
        }

        ///////////////////////////////////////////
        // PACMAN LOCATION LOGIC
        ///////////////////////////////////////////

        for (i=0; i< 4; i++) {
            //if (pacX == baddieX[i] && pacY == baddieY[i] ) {
            if (	pacXpix > ghostXpix[i] - 10  &&
                        pacXpix < ghostXpix[i] + 10  &&
                        pacYpix > ghostYpix[i] - 10  &&
                        pacYpix < ghostYpix[i] + 10  ) {

                if ( ((Ghost*)objects[i+2])->getState() == 0 )	{

                    lives--;

                    app.getSnd()->stop();
                    app.getSnd()->play(8, 0);

                    SDL_Delay(1000);

                    if ( lives == 0) {
                        if (hscore.onlist(score) ) setState( STATE_ENTER_HSCORE );
                        else gameInit();
                        return;
                    }
                    else {
                        resetLvl();
                        return;
                    }
                }

                else if  ( ((Ghost*)objects[i+2])->getState() != 3 ) {
                    ((Ghost*)objects[i+2])->setState(3);

                    app.getSnd()->play(4,0);
                    deadghostcount++;

                    floatingscore = 200;
                    for (j=1; j< deadghostcount; j++) floatingscore *= 2;
                    floatingscorebox.x = pacXpix;
                    floatingscorebox.w = 100;
                    floatingscorebox.y = pacYpix-70;
                    floatingscorebox.h = 50;

                    floatingscorecounter = 100;

                    score+= floatingscore;
                }
            }
        }

        if ( objmap[pacY * settings.fieldwidth + pacX ] == 1 ) {
            objmap[pacY * settings.fieldwidth + pacX ] = 0;
            score += SMALL_DOTS_SCORE;

            app.getSnd()->play( 1 + soundcounter%2, 0, -500);
            soundcounter++;
        }
        else if ( objmap[pacY * settings.fieldwidth + pacX ] == 2 ) {
            objmap[pacY * settings.fieldwidth + pacX ] = 0;
            score += LARGE_DOTS_SCORE;

            app.getSnd()->play(3, 0);
            app.getSnd()->play(7, 1);

            //set ghosts to vulnerable mode

            for (i=2;i<6;i++) ((Ghost*)objects[i])->setState(1);
            deadghostcount=0;	//reset dead counter

            //start ghost timer

            ghosttick = time + settings.vuln_duration;
            vulnflag = true;
        }
        else if ( objmap[pacY * settings.fieldwidth + pacX ] == 3 &&  specialspawned && !specialeaten ) {
            objmap[pacY * settings.fieldwidth + pacX ] = 0;
            score += objscore;

            app.getSnd()->play(5, 0);

            floatingscorebox.x = pacXpix;
            floatingscorebox.w = 100;
            floatingscorebox.y = pacYpix-70;
            floatingscorebox.h = 50;
            floatingscore = objscore;
            floatingscorecounter = 100;

            specialeaten = true;
            ((BckgrObj*)objects[0])->setSpecialEaten(true);
        }


        ///////////////////////////////////
        //	OTHER
        ///////////////////////////////////

        if ( (score >= 10000 && oldscore < 10000) ||
             (score >=100000 && oldscore < 100000) ||
             (score >=1000000 && oldscore < 1000000) ) {
            lives++;

            app.getSnd()->play(6, 0);
        }

        if ( !specialhasbeenspawned && ((BckgrObj*)objects[0])->getObjCount() == specialspawntime) {
            specialspawned = true;
            ((BckgrObj*)objects[0])->setFruitAlpha(255);
            ((BckgrObj*)objects[0])->setSpecialSpawned(true);
            fruittick = SDL_GetTicks() + FRUITDURATION;
        }

        if ( ((BckgrObj*)objects[0])->getObjCount() == 0 ) {
            levelcleared = true;
            render();
            nextLvl();
        }
        //		else ( app.getSnd()->modify( 10, 44100 - ((BckgrObj*)objects[0])->getObjCount() * 75) );
    }
}
void Game::renderEnterHscore() {
    shared_ptr<SDL_Surface>
            buf = app.getScreen(),
            txt;
    std::ostringstream ostr;
    SDL_Rect rect;
    SDL_Color col;
    int i;
    std::string tmp;

    col.r = col.g = col.b = 255;

    rect.x = settings.fieldwidth*settings.tilesize / 2 - 200;
    rect.w = 400;
    rect.y = settings.fieldheight*settings.tilesize / 2 - 50;
    rect.h = 50;

    try {
        // DRAW FIELD + SPRITES

        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->Draw();

        // DRAW SCORE + INFO

        for (i=1; i<lives; i++) {
            objects[PAC]->Draw( 350+i*50, settings.fieldheight*settings.tilesize+5);
        }
        if ( specialeaten ) objects[0]->Draw( settings.fieldwidth*settings.tilesize - 40 -10, settings.fieldheight*settings.tilesize +15 );

        ostr << "level: " << level << " score: " << score;

        txt.reset(TTF_RenderText_Solid(font,ostr.str().c_str(),col), SDL_FreeSurface);
        if (!txt) throw Error("DrawText failed");

        SDL_BlitSurface(txt.get(),NULL,buf.get(),&scorebox);

        // DRAW HIGHSCORE ENTRY


        txt.reset(TTF_RenderText_Solid(font,"NEW HIGHSCORE!",col), SDL_FreeSurface);
        if (!txt) throw Error("DrawText failed");

        SDL_BlitSurface(txt.get(),NULL,buf.get(),&rect);

        rect.y += 50;


        txt.reset(TTF_RenderText_Solid(font,"Enter name:",col), SDL_FreeSurface);
        if (!txt) throw Error("DrawText failed");

        SDL_BlitSurface(txt.get(),NULL,buf.get(),&rect);

        rect.y += 70;
        rect.h = 50;
        rect.x = settings.fieldwidth*settings.tilesize / 2 - 60;
        rect.w = 40;

        for (i=0;i<3;i++) {
            tmp=name[i];
            col.r=col.g=col.b=namecol[i];

            txt.reset(TTF_RenderText_Solid(font,tmp.c_str(),col), SDL_FreeSurface);
            if (!txt) throw Error("DrawText failed");

            SDL_BlitSurface(txt.get(),NULL,buf.get(),&rect);

            rect.x=rect.x+40;
        }
    }
    catch ( Error& err ) {
        std::cerr << err.getDesc();
        app.setQuit(true);
        logtxt.print( err.getDesc() );
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in Game::RenderEnterHscore";
        app.setQuit(true);
        logtxt.print( "Unexpected error" );
    }
}
void Game::renderNormal() {
    int i;
    std::ostringstream ostr;
    SDL_Color col;
    shared_ptr<SDL_Surface> txt;

    col.r = col.g = col.b = 255;

    try {
        // DRAW FIELD + SPRITES

        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->Draw();

        // DRAW SCORE + INFO

        for (i=1; i<lives; i++)
            objects[PAC]->Draw( 350+i*50, settings.fieldheight*settings.tilesize+5);

        if ( specialeaten ) objects[0]->Draw( settings.fieldwidth*settings.tilesize - 40 -10, settings.fieldheight*settings.tilesize +15 );
        if ( boostavailable ) objects[0]->Draw( settings.fieldwidth*settings.tilesize - 60 -10, settings.fieldheight*settings.tilesize +15, 4 );

        ostr << "level: " << level << " score: " << score;

        txt.reset(TTF_RenderText_Solid(font,ostr.str().c_str(),col), SDL_FreeSurface);
        if (!txt) throw Error("DrawText failed");

        SDL_BlitSurface(txt.get(),NULL,app.getScreen().get(),&scorebox);

        //DRAW SCORE POPUP
        if (floatingscorecounter != 0) {
            std::ostringstream scoretext;

            scoretext << floatingscore;
            floatingscorecounter--;

            floatingscorebox.y--;

            txt.reset(TTF_RenderText_Solid(font,scoretext.str().c_str(),col), SDL_FreeSurface);
            if (!txt) throw Error("DrawText failed");

            SDL_SetAlpha(txt.get(), SDL_SRCALPHA, 55+floatingscorecounter*2);
            SDL_BlitSurface(txt.get(),NULL,app.getScreen().get(),&floatingscorebox);
        }

        // PAUSE

        if ( ispaused ) {
            SDL_Rect pauserect;
            pauserect.y = settings.fieldwidth*settings.tilesize / 2 - 100;
            pauserect.w = 200;
            pauserect.x = settings.fieldheight*settings.tilesize / 2 - 10;
            pauserect.h = 50;

            txt.reset(TTF_RenderText_Solid(font,"PAUSED",col), SDL_FreeSurface);
            if (!txt) throw Error("DrawText failed");

            SDL_BlitSurface(txt.get(),NULL,app.getScreen().get(),&pauserect);
        }

        // LEVEL CLEARED

        else if ( levelcleared ) {
            SDL_Rect pauserect;
            pauserect.x = settings.fieldwidth*settings.tilesize / 2 - 200;
            pauserect.w = 400;
            pauserect.y = settings.fieldheight*settings.tilesize / 2 - 10;
            pauserect.h = 50;

            txt.reset(TTF_RenderText_Solid(font,"LEVEL CLEARED!",col), SDL_FreeSurface);
            if (!txt) throw Error("DrawText failed");

            SDL_BlitSurface(txt.get(),NULL,app.getScreen().get(),&pauserect);
        }
    }

    catch ( Error& err ) {
        std::cerr << err.getDesc();
        app.setQuit(true);
        logtxt.print( err.getDesc() );
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in Game::RenderNormal";
        app.setQuit(true);
        logtxt.print( "Unexpected error during RenderNormal()" );
    }
}

void Game::boost() {
    if ( boostavailable ) {

        app.getSnd()->play( 12, 0 );

        boosttick = SDL_GetTicks() + BOOSTTIME;
        isboosted = true;
        boostavailable = false;
        ((Pacman*)objects[PAC])->setSpeedMult( 2 );
    }
}
bool Game::pause() {
    int i;

    if ( !ispaused ) {
        ispaused = true;
        app.getSnd()->stop();
        for (i=0;i<NUMOFOBJECTS;i++) objects[i]->setPaused( true);

        pausetick = SDL_GetTicks();

        return ispaused;
    }
    else {
        ispaused = false;
        app.getSnd()->play(10, 1);
        if (vulnflag) app.getSnd()->play(7, 1);
        for (i=0;i<NUMOFOBJECTS;i++) objects[i]->setPaused( false);

        int delta( SDL_GetTicks() - pausetick );

        ghosttick += delta;
        fruittick += delta;
        boosttick += delta;

        return ispaused;
    }
}
void Game::nextLvl() {
    std::string tmpstr;


    try {
        level++;

        app.getSnd()->stop();
        app.getSnd()->play(9);

        objscore*=2;
        settings.vuln_duration -= settings.vuln_duration/10;

        ((Ghost*)objects[ rand()%4 +2])->changeDifficulty( rand()%15, rand()%5 );
        ((Ghost*)objects[ rand()%4 +2])->changeDifficulty( rand()%10, rand()%3 );

        objects[PAC]->reset(settings.pacstartx, settings.pacstarty);
        objects[GHOST1]->reset(settings.baddiestartx, settings.baddiestarty);
        objects[GHOST2]->reset(settings.baddiestartx+2, settings.baddiestarty);
        objects[GHOST3]->reset(settings.baddiestartx-2, settings.baddiestarty);
        objects[GHOST4]->reset(settings.baddiestartx, settings.baddiestarty-2);

        tmpstr = settings.lvlpath[settings.lvlpathcurrent] + OBJFILE;
        if ( ! loadMap(tmpstr, objmap) )
            throw Error("Error loading objmap.txt during Game::nextLvl()");

        vulnflag= false;
        deadghostcount= 0;
        floatingscorecounter = 0;
        floatingscore = 0;
        specialspawned = false;
        ((BckgrObj*)objects[0])->setSpecialSpawned(false);
        specialeaten = false;
        ((BckgrObj*)objects[0])->setSpecialEaten(false);
        specialhasbeenspawned = false;
        time = oldtime = SDL_GetTicks();
        ghosttick = 0;
        isboosted = false;
        ((Pacman*)objects[PAC])->setSpeedMult( 1);
        boostavailable = true;
        levelcleared = false;

        if (ispaused) pause();


        SDL_Delay(1000);


        render();
        specialspawntime = rand() % (((BckgrObj*)objects[0])->getObjCount() -20) + 10;

        emptyMsgPump();
        inputwaiting = false;
        gamestarted = false;
    }
    catch ( Error &err) {
        std::cerr << err.getDesc();
        app.setQuit(true);
        logtxt.print( err.getDesc() );
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in Game::nextLvl()";
        app.setQuit(true);
        logtxt.print( "Unexpected error" );
    }
}

void Game::gameInit(std::string level, std::string skin, bool editor) {
    int i;
    std::string tmpstr;

    try {
        isinit=false;
        app.getSnd()->stop();

        //try to set level/skins path
        settings.setPath(MODE_LEVELS,level);
        settings.setPath(MODE_SKINS,skin);

        tmpstr = settings.lvlpath[settings.lvlpathcurrent] + CFGFILE;

        if ( !settings.LoadSettings(tmpstr) )
            throw Error("Error loading level settings");

        //resetting variables
        score=0;
        vulnflag= false;
        deadghostcount= 0;
        ghosttick = 0;
        floatingscorecounter = 0;
        floatingscore = 0;
        lives = 3;
        level = 1;
        objscore = 200;
        specialspawned = false;
        specialeaten = false;
        specialhasbeenspawned = false;
        inputwaiting = false;
        gamestarted = false;
        isboosted = false;
        time = oldtime = SDL_GetTicks();
        boostavailable = true;
        levelcleared = false;
        setState( STATE_GAME);
        name = "AAA";
        namecol[0] = 255;
        namecol[1] = 150;
        namecol[2] = 150;
        hscoreselection = 0;


        if ( ispaused )
            pause();

        scorebox.x= 20;
        scorebox.w = 500;
        scorebox.y = settings.fieldheight * settings.tilesize ;
        scorebox.h = 50;



        //DYNAMIC OBJECTS INIT
        if (map!=NULL) {
            delete[] map;
            map=NULL;
        }
        if (objmap!=NULL) {
            delete[] objmap;
            objmap=NULL;
        }
        for (i=0; i< NUMOFOBJECTS; i++) {
            if (objects[i]!=NULL) {
                delete objects[i];
                objects[i] = NULL;
            }
        }

        logtxt.print("Unloading complete");

        //if level has different field size than currently selected, setup new window with proper size
        if (settings.fieldwidth*settings.tilesize != app.getScreen()->w
            || settings.fieldheight*settings.tilesize+EXTRA_Y_SPACE != app.getScreen()->h) {
            app.InitWindow();
            logtxt.print("window resized...");
        }

        // INIT MAPS
        map = new int[settings.fieldheight*settings.fieldwidth];
        objmap = new int[settings.fieldheight*settings.fieldwidth];

        tmpstr = settings.lvlpath[settings.lvlpathcurrent];

        if ( !loadMap(tmpstr + MAPFILE, map) )
            throw Error("Failed to load map.txt");
        if ( !loadMap(tmpstr + OBJFILE, objmap) )
            throw Error("Failed to load objmap.txt");

        logtxt.print("Maps loaded");

        //creating font

        if ( !font ) loadFont();

        logtxt.print("Font created");

        //loading level graphics

        objects[0] = new BckgrObj( app.getScreen(), 10 );
        objects[0]->LoadTextures(APP_PATH "/" + settings.skinspath[settings.skinspathcurrent]);

        logtxt.print("Level background loaded");

        logtxt.print("Sounds loaded");

        app.getSnd()->play(9, 0);

        setState( STATE_STOPPED);

        hscore.setfilename(settings.lvlpath[settings.lvlpathcurrent] + "hscore");
        hscore.load();


        //create pacman + ghosts

        objects[1] = new Pacman( app.getScreen(),
                            20,
                            settings.pacstartx,
                            settings.pacstarty,
                            settings.pacspeed,
                            settings.tilesize,
                            settings.fieldheight,
                            settings.fieldwidth,
                            map);
        objects[1]->LoadTextures(APP_PATH "/" + settings.skinspath[settings.skinspathcurrent]);

        objects[2] = new Ghost( app.getScreen(),
                            20,
                            settings.baddiestartx,
                            settings.baddiestarty,
                            settings.baddiespeed + rand()%20 + 10,
                            settings.tilesize,
                            settings.fieldheight,
                            settings.fieldwidth,
                            map,
                            "1");
        objects[2]->LoadTextures(APP_PATH "/" + settings.skinspath[settings.skinspathcurrent]);

        objects[3] = new Ghost( app.getScreen(),
                            20,
                            settings.baddiestartx+2,
                            settings.baddiestarty,
                            settings.baddiespeed + rand()%20-10,
                            settings.tilesize,
                            settings.fieldheight,
                            settings.fieldwidth,
                            map,
                            "2");
        objects[3]->LoadTextures(APP_PATH "/" + settings.skinspath[settings.skinspathcurrent]);

        objects[4] = new Ghost( app.getScreen(),
                            20,
                            settings.baddiestartx-2,
                            settings.baddiestarty,
                            settings.baddiespeed + rand()%20-10,
                            settings.tilesize,
                            settings.fieldheight,
                            settings.fieldwidth,
                            map,
                            "3");
        objects[4]->LoadTextures(APP_PATH "/" + settings.skinspath[settings.skinspathcurrent]);

        objects[5] = new Ghost( app.getScreen(),
                            20,
                            settings.baddiestartx,
                            settings.baddiestarty-2,
                            settings.baddiespeed + rand()%20 - 10,
                            settings.tilesize,
                            settings.fieldheight,
                            settings.fieldwidth,
                            map,
                            "4");
        objects[5]->LoadTextures(APP_PATH "/" + settings.skinspath[settings.skinspathcurrent]);

        for (i=0;i<4;i++) ((Ghost*)objects[i+2])->changeDifficulty(0, settings.baddieiq);	//SET DIFFICULTY SPECIFIED IN CONFIG FILE

        logtxt.print("Objects loaded");

        //calculate special fruit spawn time

        if (!editor) render();
        specialspawntime = rand() % (((BckgrObj*)objects[0])->getObjCount() -20) + 10;

        emptyMsgPump();
        inputwaiting = false;
        gamestarted = false;

        isinit = true;

        if (editor) {
            initEditor();
            setState(STATE_EDITOR);
        }
    }
    catch ( Error &err) {
        std::cerr << err.getDesc();
        app.setQuit(true);
        logtxt.print( err.getDesc() );
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in Game::gameInit()";
        app.setQuit(true);
        logtxt.print( "Unexpected error" );
    }
}


void Game::resetLvl() {	// vars and positions when pacman dies during level

    app.getSnd()->stop();

    SDL_Delay(1000);

    app.getSnd()->play(9);


    // setting vars
    vulnflag= false;
    deadghostcount= 0;
    floatingscorecounter= 0;
    floatingscore= 0;
    ghosttick = 0;
    isboosted = false;
    ((Pacman*)objects[PAC])->setSpeedMult( 1);

    if (ispaused) pause();

    objects[PAC]->reset(settings.pacstartx, settings.pacstarty);
    objects[GHOST1]->reset(settings.baddiestartx, settings.baddiestarty);
    objects[GHOST2]->reset(settings.baddiestartx+2, settings.baddiestarty);
    objects[GHOST3]->reset(settings.baddiestartx-2, settings.baddiestarty);
    objects[GHOST4]->reset(settings.baddiestartx, settings.baddiestarty-2);

    render();

    emptyMsgPump();
    gamestarted= false;
    inputwaiting = false;
}
void Game::processInput(int k, int ix, int iy) {

    inputwaiting = true;

    key = k;
    if ( k == CLICK ) {
        mouseX = ix;
        mouseY = iy;
    }

    if ( !gamestarted && !ispaused ) {
        gamestarted = true;
        if ( state == STATE_STOPPED || state == STATE_GAME )
            setState( STATE_GAME );
    }
}

void Game::processLogic() {

    time = SDL_GetTicks();

    if ( state == STATE_GAME ) logicGame();
    else if (state == STATE_ENTER_HSCORE ) logicEnterHscore();
    else if (state == STATE_EDITOR ) logicEditor();

    oldtime = time;
    inputwaiting = false;
}

void Game::getMaps( int **m, int **o) {
    (*m)=map;
    (*o)=objmap;
}
bool Game::loadMap(std::string file, int* memmap) {
    int i, count=0, size = settings.fieldheight * settings.fieldwidth;
    std::string tmp;
    char c('i');
    std::ifstream mp;

    file = settings.getFile(file);
    mp.open( file.c_str() );

    if (!mp ) {
        logtxt.print(file + " - Loading error");
        app.setQuit(true);
        return false;
    }

    for (i=0;i<size;i++) {
        do {
            if ( mp.eof() ) break;
            c=mp.get();
            if (c == '/' ) {	// enable comments in map file by prefixing line with  a slash
                getline(mp, tmp);
                continue;
            }
        }
        while (! (c >= '0' && c <= '9') ) ;
        memmap[i]=c-48;
        count++;
        if (!mp) break;
    }

    if ( mp.is_open() ) mp.close();

    if (count != size) {
        logtxt.print(file + " - Loading error");
        app.setQuit(true);
        return false;
    }

    logtxt.print(file + " loaded");
    return true;
}


std::string Game::getFPS() {
    unsigned int newtick = SDL_GetTicks();
    std::ostringstream ostr;
    float diff;

    diff = (float)(newtick-ticks) / (float)counter;	// ms per frame

    diff = 1000.0f / diff;			// frames per s

    ostr << diff << "fps";

    ticks = newtick;

    return ostr.str();
}

void Game::render() {
    shared_ptr<SDL_Surface>
            buf = app.getScreen(),
            txt;
    SDL_Color
            col;

    col.r = col.g = col.b = 255;

    if (counter == 100) {
        fps = getFPS();
        counter = 0;
    }

    try {
        if ( !renderisbusy ) {
            renderisbusy = true;

            ////////////////////////////////
            // STATE SWITCH
            ////////////////////////////////

            if ( (state == STATE_GAME) || (state == STATE_STOPPED) ) renderNormal();
            else if (state == STATE_ENTER_HSCORE ) renderEnterHscore();
            else if (state == STATE_VIEW_HSCORE ) renderViewHscore();
            else if (state == STATE_EDITOR )renderEditor();


            if ( showfps ) {
                txt.reset(TTF_RenderText_Solid(font,fps.c_str(),col), SDL_FreeSurface);
                if (!txt) throw Error("DrawText failed");

                SDL_BlitSurface(txt.get(),NULL,buf.get(),&fpsbox);
            }

            SDL_Flip(buf.get());

            renderisbusy = false;
            counter++;
        }
    }
    catch ( Error& err ) {
        std::cerr << err.getDesc();
        app.setQuit(true);
        logtxt.print( err.getDesc() );
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in Game::Render";
        app.setQuit(true);
        logtxt.print( "Unexpected error during Render()" );
    }
}

bool Game::loadFont() {

    try {
        font = TTF_OpenFont(APP_PATH "/" "arial.ttf",24);
        if (!font)
            throw Error("Failed to create font object ");
    }
    catch ( Error& err ) {
        std::cerr << err.getDesc();
        app.setQuit(true);
        logtxt.print( err.getDesc() );
        return false;
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in Game::loadFont";
        app.setQuit(true);
        logtxt.print( "Unexpected error while loading font" );
        return false;
    }

    logtxt.print("Font loaded");
    return true;
}

void Game::PrepareShutdown() {
    int i;

    if ( font ) TTF_CloseFont(font);
    for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) delete objects[i];
}
Game::Game()
:   isinit(false),
    state(STATE_STOPPED),
    counter(0),
    font(NULL),
    map(NULL),
    objmap(NULL),
    deadghostcount(0),
    lives(2),
    objscore(200),
    floatingscore(0),
    floatingscorecounter(0),
    specialspawntime(0),
    level(1),
    hscoreselection(0),
    soundcounter(0),
    inputwaiting(false),
    gamestarted(false),
    vulnflag(false),
    specialspawned(false),
    specialeaten(false),
    specialhasbeenspawned(false),
    ispaused(false),
    isboosted(false),
    showfps(false),
    renderisbusy(false)

{
    int i;

    time = oldtime = ticks = SDL_GetTicks();

    fps = "loading";

    fpsbox.x= 10;
    fpsbox.w = 290;
    fpsbox.y = 10;
    fpsbox.h = 190;

    for (i=0;i<NUMOFOBJECTS;i++) objects[i]=NULL;

    for (i=0;i<10;i++)
        num[i]='0'+i;

    name = "AAA";
    namecol[0] = 255;
    namecol[1] = 150;
    namecol[2] = 150;
}

Game::~Game()
{
    if ( map ) delete[] map;
    if ( objmap ) delete[] objmap;
}
